

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>UQ Forward Problem &mdash; UQit 1.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Global Sensitivity Analysis (GSA)" href="gsa.html" />
    <link rel="prev" title="Surrogates" href="surrogate.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> UQit
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="instl_dep.html">Installation and Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="codes_list.html">List of core codes</a></li>
<li class="toctree-l1"><a class="reference internal" href="terminology.html">Overview &amp; Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="surrogate.html">Surrogates</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">UQ Forward Problem</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#standard-polynomial-chaos-expansion">Standard Polynomial Chaos Expansion</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#theory">Theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notebook">Notebook</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#probabilistic-polynomial-chaos-expansion">Probabilistic Polynomial Chaos Expansion</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">Theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">Notebook</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="gsa.html">Global Sensitivity Analysis (GSA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="others.html">Other Core Codes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bib.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">UQit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>UQ Forward Problem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/UQit_core_/uqFWD.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="uq-forward-problem">
<span id="uqfwd-sect"></span><h1>UQ Forward Problem<a class="headerlink" href="#uq-forward-problem" title="Permalink to this headline">¶</a></h1>
<p>In UQ forward (uncertainty propagation) problems, the aim is to estimate the propagation of uncertainties in the model response or QoIs, from known uncertain parameters/inputs.
In many situations, we are mostly interested in approximately estimating the statistical moments of the model outputs and QoIs.
In particular, among the moments, our main focus is on the expected value <span class="math notranslate nohighlight">\(\mathbb{E}_\mathbf{q}[r]\)</span> and variance <span class="math notranslate nohighlight">\(\mathbb{V}_\mathbf{q}[r]\)</span> of a QoI <span class="math notranslate nohighlight">\(r\)</span>, with <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> denoting the uncertain parameters.
Different approaches can be used for this purpose, see <a class="reference internal" href="../bib.html#smith13" id="id1"><span>[Smith13]</span></a>, <a class="reference internal" href="../bib.html#ghanem17" id="id2"><span>[Ghanem17]</span></a>.
The Monte Carlo approaches rely on taking independent samples from the parameters and running the model simulator as a blackbox.
However, the convergence rate of these methods can be low, see e.g. <a class="reference internal" href="../bib.html#ghanem17" id="id3"><span>[Ghanem17]</span></a>.
As a more efficient technique, the spectral-based method non-intrusive generalized polynomial chaos expansion (gPCE) <a class="reference internal" href="../bib.html#xiu02" id="id4"><span>[Xiu02]</span></a>, <a class="reference internal" href="../bib.html#xiu05" id="id5"><span>[Xiu05]</span></a>, <a class="reference internal" href="../bib.html#xiu07" id="id6"><span>[Xiu07]</span></a> is employed in <code class="code docutils literal notranslate"><span class="pre">UQit</span></code> for UQ forward problems.
For an overview of the technique with the same notations as in this document, refer to <a class="reference internal" href="../bib.html#rezaeiravesh20" id="id7"><span>[Rezaeiravesh20]</span></a>.</p>
<div class="section" id="standard-polynomial-chaos-expansion">
<span id="gpce-sect"></span><h2>Standard Polynomial Chaos Expansion<a class="headerlink" href="#standard-polynomial-chaos-expansion" title="Permalink to this headline">¶</a></h2>
<div class="section" id="theory">
<h3>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h3>
<p>The generalized polynomial chaos expansion for <span class="math notranslate nohighlight">\(\tilde{f}(\chi,\mathbf{q})\)</span> is written as,</p>
<div class="math notranslate nohighlight">
\[\tilde{f}(\chi,\mathbf{q}) = \sum_{k=0}^K \hat{f}_k(\chi) \Psi_{k}(\xi) \,,\]</div>
<p>where the basis function for the multi-variate parameter <span class="math notranslate nohighlight">\(\xi\in\Gamma\)</span> is defined as <span class="math notranslate nohighlight">\(\Psi_{k}(\xi)=\prod_{i=1}^p \psi_{k_i}(\xi_i)\)</span>.
In the framework of generalized PCE, see <a class="reference internal" href="../bib.html#xiu02" id="id8"><span>[Xiu02]</span></a>, given the distribution of the single-variate parameter <span class="math notranslate nohighlight">\(\xi_i\in \Gamma_i\)</span>, a set of orthogonal basis functions are chosen for <span class="math notranslate nohighlight">\(\psi_{k_i}(\xi_i)\)</span>, for <span class="math notranslate nohighlight">\(i=1,2,\ldots,p\)</span>.
Note that, there is a one-to-one correspondence between any sample of <span class="math notranslate nohighlight">\(\mathbf{q}\in \mathbb{Q}\)</span> and <span class="math notranslate nohighlight">\(\xi\in\Gamma\)</span>, where <span class="math notranslate nohighlight">\(\mathbb{Q}=\bigotimes_{i=1}^p \mathbb{Q}_i\)</span> and <span class="math notranslate nohighlight">\(\Gamma=\bigotimes_{i=1}^p \Gamma_i\)</span>.
The mapped space <span class="math notranslate nohighlight">\(\Gamma_i\)</span> is known based on the gPCE rule, see <a class="reference internal" href="../bib.html#xiu02" id="id9"><span>[Xiu02]</span></a>, <a class="reference internal" href="../bib.html#eldred09" id="id10"><span>[Eldred09]</span></a>.</p>
<p>Given a set of training data <span class="math notranslate nohighlight">\(\mathcal{D}=\{(\mathbf{q}^{(i)},r^{(i)})\}_{i=1}^n\)</span>, there are two main steps to construct the above expansion.
First, a truncation scheme is needed to handle <span class="math notranslate nohighlight">\(p\)</span>-dimensional parameter space and determine <span class="math notranslate nohighlight">\(K\)</span>.
Currently, tensor-product and total-order schemes are available in <code class="code docutils literal notranslate"><span class="pre">UQit</span></code>.
Second, the coefficients <span class="math notranslate nohighlight">\(\{\hat{f}_k(\chi)\}_{k=0}^K\)</span> have to be determined.
In <code class="code docutils literal notranslate"><span class="pre">UQit</span></code>, two different approaches can be used for this purpose: projection and regression method, see <a class="reference internal" href="../bib.html#rezaeiravesh20" id="id11"><span>[Rezaeiravesh20]</span></a> and the references therein.
In case the number of training data is less than <span class="math notranslate nohighlight">\(K\)</span>, compressed sensing method can be adopted which is implemented in <code class="code docutils literal notranslate"><span class="pre">UQit</span></code> through the external Python library <code class="code docutils literal notranslate"><span class="pre">cvxpy</span></code> <a class="reference internal" href="../bib.html#diamond16" id="id12"><span>[Diamond16]</span></a>.</p>
<p>Once the coefficients <span class="math notranslate nohighlight">\(\{\hat{f}_k(\chi)\}_{k=0}^K\)</span> are obtained, the PCE can be used as a surrogate for the actual unobserved <span class="math notranslate nohighlight">\(f(\chi,\mathbf{q})\)</span>.
A main advantage of the PCE method is that the approximate estimation of the statistical moments of the <span class="math notranslate nohighlight">\(f(\chi,\mathbf{q})\)</span> or response <span class="math notranslate nohighlight">\(r\)</span> is a natural outcome of the surrogate construction.
Using gPCE, the mean and variance of the simulator are estimated by,</p>
<div class="math notranslate nohighlight">
\[\mathbb{E}_{\mathbf{q}}[f(\chi,\mathbf{q})] = \hat{f}_0(\chi),\]</div>
<div class="math notranslate nohighlight">
\[\mathbb{V}_{\mathbf{q}}[f(\chi,\mathbf{q})] = \sum_{k=1}^K \hat{f}^2_k(\chi) \gamma_k,\]</div>
<p>where <span class="math notranslate nohighlight">\(\gamma_k\)</span> is the inner-product of the polynomial basis.</p>
</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>In <code class="code docutils literal notranslate"><span class="pre">UQit</span></code>, to construct and estimate expected value and variance of <span class="math notranslate nohighlight">\(f(\mathbf{q})\)</span> for <span class="math notranslate nohighlight">\(\mathbf{q}\in\mathbb{Q}\subset \mathbb{R}^p\)</span>, we have:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pce_</span><span class="o">=</span><span class="n">pce</span><span class="p">(</span><span class="n">fVal</span><span class="o">=</span><span class="n">fVal</span><span class="p">,</span><span class="n">xi</span><span class="o">=</span><span class="n">xiGrid</span><span class="p">,</span><span class="n">pceDict</span><span class="o">=</span><span class="n">pceDict</span><span class="p">,</span><span class="n">nQList</span><span class="o">=</span><span class="n">nQ</span><span class="p">)</span>
<span class="n">fMean</span><span class="o">=</span><span class="n">pce_</span><span class="o">.</span><span class="n">fMean</span>
<span class="n">fVar</span><span class="o">=</span><span class="n">pce_</span><span class="o">.</span><span class="n">fVar</span>
<span class="n">pceCoefs</span><span class="o">=</span><span class="n">pce_</span><span class="o">.</span><span class="n">coefs</span>
<span class="n">kSet</span><span class="o">=</span><span class="n">pce_</span><span class="o">.</span><span class="n">kSet</span>
</pre></div>
</div>
<p>To evaluate a constructed PCE at a set of test parameter samples taken from <span class="math notranslate nohighlight">\(\Gamma\)</span>, we write:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pcePred_</span><span class="o">=</span><span class="n">pce</span><span class="o">.</span><span class="n">pceEval</span><span class="p">(</span><span class="n">coefs</span><span class="o">=</span><span class="n">pceCoefs</span><span class="p">,</span><span class="n">xi</span><span class="o">=</span><span class="n">xiTest</span><span class="p">,</span><span class="n">distType</span><span class="o">=</span><span class="n">distType</span><span class="p">,</span><span class="n">kSet</span><span class="o">=</span><span class="n">kSet</span><span class="p">)</span>
<span class="n">fPCE</span><span class="o">=</span><span class="n">pcePred_</span><span class="o">.</span><span class="n">pceVal</span>
</pre></div>
</div>
<p>As for instance described in <a class="reference internal" href="../bib.html#rezaeiravesh20" id="id13"><span>[Rezaeiravesh20]</span></a>, as an a-posteriori measure of the convergence of the PCE terms, we can evaluate the following indicator,</p>
<div class="math notranslate nohighlight">
\[\vartheta_\mathbf{k} = |\hat{f}_\mathbf{k}| \, \|\Psi_{\mathbf{k}}(\mathbf{\xi})\|_2/|\hat{f}_0|\]</div>
<p>at different multi-indices <span class="math notranslate nohighlight">\(\mathbf{k}\)</span>.
In <code class="code docutils literal notranslate"><span class="pre">UQit</span></code> this is done through running,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pce</span><span class="o">.</span><span class="n">convPlot</span><span class="p">(</span><span class="n">coefs</span><span class="o">=</span><span class="n">pceCoefs</span><span class="p">,</span><span class="n">distType</span><span class="o">=</span><span class="n">distType</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>In <code class="code docutils literal notranslate"><span class="pre">UQit</span></code>, the methods required for standard PCE are implemented in <code class="code docutils literal notranslate"><span class="pre">pce.py</span></code>.</p>
<span class="target" id="module-pce"></span><dl class="py class">
<dt id="pce.convPlot">
<em class="property">class </em><code class="sig-prename descclassname">pce.</code><code class="sig-name descname">convPlot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coefs</span></em>, <em class="sig-param"><span class="n">distType</span></em>, <em class="sig-param"><span class="n">kSet</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">convPltOpts</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pce.convPlot" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and plots the convergence indicator of a PCE that is defined as,</p>
<div class="math notranslate nohighlight">
\[\vartheta_k = ||f_k \Psi_k||/|f_0|\]</div>
<p>versus <span class="math notranslate nohighlight">\(|k|=\sum_{i=1}^p k_i\)</span>.
The dimension of the parameter space, p, is arbitrary. But for p&gt;1, kSet have to 
be provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt><cite>coefs</cite>: 1D numpy array of length K</dt><dd><p>The PCE coefficients</p>
</dd>
<dt><cite>distType</cite>: List of length p of strings, </dt><dd><p>The i-th value specifies the distribution type of the i-th parameter (based on the gPCE rule)</p>
</dd>
<dt><cite>kSet</cite>: (optional, required only if p&gt;1) List of length <cite>K</cite></dt><dd><p>The index set produced when constructing the PCE with a specified truncation scheme.          
<span class="math notranslate nohighlight">\(kSet=[[k_{1,1},k_{2,1},...k_{p,1}],...,[k_{1,K},k_{2,K},..,k_{p,K}]]\)</span> with <span class="math notranslate nohighlight">\(k_{i,j}\)</span> being integer.</p>
</dd>
<dt><cite>convPltOpts</cite>: (optional) dict</dt><dd><dl class="simple">
<dt>Containing the options to save the figure. It includes the following keys:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>‘figDir’: </dt><dd><p>Path to the directory at which the figure is saved (if not exists, is created)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘figName’: </dt><dd><p>Name of the figure</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl class="simple">
<dt><cite>kMag</cite>: List of K integers</dt><dd><p><cite>=|k|</cite>, sum of the PCE uni-directional indices</p>
</dd>
<dt><cite>pceConvIndic</cite>: 1D numpy array of size K</dt><dd><p>The PCE convergence indicator</p>
</dd>
</dl>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt><cite>pceConv()</cite>:</dt><dd><p>Computes the convergence indicator</p>
</dd>
<dt><cite>pceConvPlot()</cite>:</dt><dd><p>Plots the PCE convergence indicator</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="pce.convPlot.pceConv">
<code class="sig-name descname">pceConv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.convPlot.pceConv" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the convergence indicator</p>
</dd></dl>

<dl class="py method">
<dt id="pce.convPlot.pceConvPlot">
<code class="sig-name descname">pceConvPlot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.convPlot.pceConvPlot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the PCE convergence indicator</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pce.pce">
<em class="property">class </em><code class="sig-prename descclassname">pce.</code><code class="sig-name descname">pce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fVal</span></em>, <em class="sig-param"><span class="n">xi</span></em>, <em class="sig-param"><span class="n">pceDict</span></em>, <em class="sig-param"><span class="n">nQList</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs non-intrusive generalized Polynomial Chaos Expansion (PCE).
The parameter space has dimension p.
We have taken n samples from the p-D parameter space and evaluated the 
simulator at each sample. 
The samples can be taken using any approach, it is only enough to set the options correctly.
The general aim is to estimate <span class="math notranslate nohighlight">\(\hat{f}_k\)</span> in</p>
<div class="math notranslate nohighlight">
\[f(q)=\sum_{k=0}^K \hat{f}_k \psi_k(\xi)\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\psi_k(\xi)=\psi_{k_1}(\xi_1)\psi_{k_2}(\xi_2)\cdots\psi_{k_p}(\xi_p)\]</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt><cite>fVal</cite>: 1D numpy array of size n</dt><dd><p>Simulator’s response values at n training samples.</p>
</dd>
<dt><cite>xi</cite>: 2D numpy array of shape (n,p)</dt><dd><p>Training parameter samples over the mapped space.
NOTE: Always have to be provided unless <cite>‘sampleType’:’GQ’</cite> .</p>
</dd>
<dt><cite>nQList</cite>: (optional) List of length p, </dt><dd><dl class="simple">
<dt><cite>nQList=[nQ1,nQ2,…,nQp]</cite>, where <cite>nQi</cite>: number of samples in i-th direction</dt><dd><ul class="simple">
<li><p>nQList=[] (default) if p==1 or p&gt;1 and <cite>‘truncMethod’:’TO’</cite></p></li>
<li><p>Required only if p&gt;1 and  <cite>‘truncMethod’:’TP’</cite></p></li>
</ul>
</dd>
</dl>
</dd>
<dt><cite>pceDict</cite>: dict</dt><dd><dl class="simple">
<dt>Contains settings required for constructing the PCE. The keys are:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt><cite>‘p’</cite>: int</dt><dd><p>Dimension of the parameter</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>‘distType’</cite>: List of length p, </dt><dd><p>The i-th value specifies the distribution type of the i-th parameter (based on the gPCE rule)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>‘sampleType’</cite>: string </dt><dd><dl class="simple">
<dt>Type of parameter samples at which observations are made</dt><dd><ul>
<li><p><cite>‘GQ’</cite> (Gauss quadrature nodes)</p></li>
<li><p><cite>‘ ‘</cite>  (other nodal sets, see <cite>class trainSample</cite> in <cite>sampling.py</cite>)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>‘pceSolveMethod’</cite>: string</dt><dd><dl class="simple">
<dt>Method of solving for the PCE coefficients</dt><dd><ul>
<li><p><cite>‘Projection’</cite>: Projection method; samples have to be Gauss-quadrature nodes.</p></li>
<li><p><cite>‘Regression’</cite>: Regression method for uniquely-, over-, and under-determined systems.
If under-determined, compressed sensing with L1/L2 regularization is automatically used.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>‘truncMethod’</cite>: string (mandatory only if p&gt;1) </dt><dd><dl class="simple">
<dt>Method of truncating the PCE</dt><dd><ul>
<li><p><cite>‘TP’</cite>: Tensor-Product method</p></li>
<li><p><cite>‘TO’</cite>: Total-Order method</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>‘LMax’</cite>: int (optional)</dt><dd><dl class="simple">
<dt>Maximum order of the PCE in each of the parameter dimensions. </dt><dd><dl class="simple">
<dt>It is mandatory for p&gt;1 and <cite>‘TuncMethod’==’TO’</cite></dt><dd><ul>
<li><p><cite>‘LMax’</cite> can be used only with <cite>‘pceSolveMethod’:’Regression’</cite></p></li>
<li><p>If p==1 and <cite>‘LMax’</cite> is not provided, it will be assumed to be equal to n.</p></li>
<li><p>If p&gt;1 and <cite>‘LMax’</cite> is not provided, it will be assumed to a default value.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt><cite>verbose</cite>: bool (optional)</dt><dd><p>If True (default), info is printed about the PCE being constructed</p>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl class="simple">
<dt><cite>coefs</cite>: 1D numpy array of size K </dt><dd><p>Coefficients in the PCE</p>
</dd>
<dt><cite>fMean</cite>: scalar</dt><dd><p>PCE estimation for E[f(q)]</p>
</dd>
<dt><cite>fVar</cite>: scalar</dt><dd><p>PCE estimation for V[f(q)]</p>
</dd>
<dt><cite>kSet</cite>: List (size K) of p-D lists, p&gt;1</dt><dd><p>Index set <span class="math notranslate nohighlight">\([[k_{1,1},k_{2,1},...k_{p,1}],...,[k_{1,K},k_{2,K},..,k_{p,K}]]\)</span>
If p==1, then kSet=[]</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="pce.pce.basis">
<em class="property">classmethod </em><code class="sig-name descname">basis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_</span></em>, <em class="sig-param"><span class="n">xi_</span></em>, <em class="sig-param"><span class="n">distType_</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates gPCE polynomial basis of order <cite>n_</cite> at <cite>xi_</cite> points taken from the mapped 
space <span class="math notranslate nohighlight">\(\Gamma\)</span>.
The standard polynomials are chosen based on the gPCE rules.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt><cite>n_</cite>: int</dt><dd><p>Order of the basis</p>
</dd>
<dt><cite>xi_</cite>: 1D numpy array of size m</dt><dd><p>Points taken from the mapped space</p>
</dd>
<dt><cite>distType_</cite>: string</dt><dd><p>Distribution type of the random parameter (based on the gPCE rule)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt><cite>psi</cite>: 1D numpy array of size m</dt><dd><p>Values of the gPCE basis at <cite>xi_</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.basisNorm">
<em class="property">classmethod </em><code class="sig-name descname">basisNorm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k_</span></em>, <em class="sig-param"><span class="n">distType_</span></em>, <em class="sig-param"><span class="n">nInteg</span><span class="o">=</span><span class="default_value">10000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.basisNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the L2-norm of the gPCE polynomial basis of order <cite>k_</cite> at <cite>nInteg</cite> points taken from the 
mapped space <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt><cite>k_</cite>: int</dt><dd><p>Order of the gPCE basis</p>
</dd>
<dt><cite>distType_</cite>: string</dt><dd><p>Distribution type of the random parameter (according to the gPCE rule)</p>
</dd>
<dt><cite>nInteg</cite>: int (optional)  </dt><dd><p>Number of points to evaluate the L2-norm integral</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt><cite>xi_</cite>: scalar</dt><dd><p>L2-norm of the gPCE basis of order <cite>k_</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.cnstrct">
<code class="sig-name descname">cnstrct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.cnstrct" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a PCE over a p-D parameter space (p=1,2,3,…)</p>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.cnstrct_1d">
<code class="sig-name descname">cnstrct_1d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.cnstrct_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a PCE over a 1D parameter space, i.e. p=1.</p>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.cnstrct_GQTP_pd">
<code class="sig-name descname">cnstrct_GQTP_pd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.cnstrct_GQTP_pd" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Constructs a PCE over a pD parameter space (p&gt;1) using the following settings:</dt><dd><ul class="simple">
<li><p><cite>‘sampType’:’GQ’</cite> (Gauss-Quadrature nodes)</p></li>
<li><p><cite>‘truncMethod’: ‘TP’</cite> (Tensor-product)</p></li>
<li><p><cite>‘pceSolveMethod’:’Projection’</cite> or ‘Regression’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.cnstrct_GQ_1d">
<code class="sig-name descname">cnstrct_GQ_1d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.cnstrct_GQ_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a PCE over a 1D parameter space using Projection method with Gauss-quadrature nodes.</p>
<dl class="simple">
<dt>Args:       </dt><dd><dl class="simple">
<dt><cite>fVal</cite>: 1D numpy array of size <cite>n</cite></dt><dd><p>Simulator’s response values at <cite>n</cite> training samples</p>
</dd>
<dt><cite>pceDict[‘distType’]</cite>: List of length 1</dt><dd><p>=[distType1], where distType1:string specifies the distribution type of the parameter 
based on the gPCE rule</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.cnstrct_nonGQTP_pd">
<code class="sig-name descname">cnstrct_nonGQTP_pd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.cnstrct_nonGQTP_pd" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Constructs a PCE over a pD parameter space (p&gt;1), for the following settings:</dt><dd><ul class="simple">
<li><p><cite>‘truncMethod’</cite>: <cite>‘TO’</cite> or <cite>‘TP’</cite></p></li>
<li><p><cite>‘pceSolveMethod’</cite>: <cite>‘Regression’</cite> (only allowed method)</p></li>
<li><p>This method is used  for any combination of <cite>‘sampleType’</cite> and <cite>‘truncMethod’</cite> 
but <cite>‘GQ’`+</cite>’TP’`</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.cnstrct_nonGQ_1d">
<code class="sig-name descname">cnstrct_nonGQ_1d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.cnstrct_nonGQ_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a PCE over a 1D parameter space using ‘Regression’ method 
with arbitrary truncation <cite>K=LMax</cite> to compute the PCE coefficients for arbitrarily
chosen parameter samples.</p>
<dl class="simple">
<dt>Args:       </dt><dd><dl class="simple">
<dt><cite>fVal</cite>: 1D numpy array of size <cite>n</cite></dt><dd><p>Simulator’s response values at <cite>n</cite> training samples</p>
</dd>
<dt><cite>pceDict[‘distType’]</cite>: List of length 1, </dt><dd><p>=[distType1], where distType1:string specifies the distribution type of the parameter 
based on the gPCE rule</p>
</dd>
<dt><cite>xi</cite>: 2D numpy array of size (n,1)</dt><dd><p>Training parameter samples over the mapped space</p>
</dd>
<dt><cite>pceDict[‘LMax’]</cite>: int </dt><dd><p>Maximum order of the PCE. 
<cite>LMax</cite> is required since <cite>‘pceSolveMethod’==’Regression’</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.cnstrct_pd">
<code class="sig-name descname">cnstrct_pd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.cnstrct_pd" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a PCE over a p-D parameter space, where p&gt;1.</p>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.density">
<em class="property">classmethod </em><code class="sig-name descname">density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xi_</span></em>, <em class="sig-param"><span class="n">distType_</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.density" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the PDF of the standard gPCE random variables with distribution 
type <cite>distType_</cite> at points <cite>xi_</cite> taken from the mapped space <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt><cite>xi_</cite>: 1D numpy array of size n</dt><dd><p>Samples taken from the mapped space</p>
</dd>
<dt><cite>distType_</cite>: string</dt><dd><p>Distribution type of the random parameter (according to the gPCE rule)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt><cite>pdf_</cite>: 1D numpy array of size n</dt><dd><p>PDF of the random parameter (according to the gPCE rule)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.gqPtsWts">
<em class="property">classmethod </em><code class="sig-name descname">gqPtsWts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_</span></em>, <em class="sig-param"><span class="n">type_</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.gqPtsWts" title="Permalink to this definition">¶</a></dt>
<dd><p>Gauss quadrature nodes and weights associated to distribution type <cite>type_</cite>
based on the gPCE rule.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt><cite>n_</cite>: int, </dt><dd><p>Order of the gPCE polynomial.</p>
</dd>
<dt><cite>type_</cite>: string, </dt><dd><p>Distribution of the random variable according to the gPCE rule</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt><cite>quads</cite>: 1D numpy array of size <cite>n_</cite> </dt><dd><p>Gauss quadrature nodes</p>
</dd>
<dt><cite>weights</cite>: 1D numpy array of size <cite>n_</cite> </dt><dd><p>Gauss quadrature weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.mapFromUnit">
<em class="property">classmethod </em><code class="sig-name descname">mapFromUnit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xi_</span></em>, <em class="sig-param"><span class="n">xBound_</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.mapFromUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>Linearly maps <cite>xi_</cite>  in <cite>[-1,1]</cite> to <cite>x</cite> in <cite>xBound_</cite></p>
<dl>
<dt>Args:</dt><dd><p><cite>xi_</cite>: Either a scalar or a 1D numpy array</p>
<p><cite>xBound_</cite>: A list of length 2 specifying the range of <cite>x_</cite></p>
</dd>
<dt>Returns:</dt><dd><p><cite>x_</cite>: Mapped value of <cite>xi_</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.mapToUnit">
<em class="property">classmethod </em><code class="sig-name descname">mapToUnit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_</span></em>, <em class="sig-param"><span class="n">xBound_</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.mapToUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>Linearly maps <cite>x_</cite> in <cite>xBound_</cite> to <cite>xi_</cite> in <cite>[-1,1]</cite></p>
<dl>
<dt>Args:</dt><dd><p><cite>x_</cite>: Either a scalar or a 1D numpy array</p>
<p><cite>xBound_</cite>: A list of length 2 specifying the range of <cite>x_</cite></p>
</dd>
<dt>Returns:</dt><dd><p><cite>xi_</cite>: Mapped value of <cite>x_</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pce.pce.map_xi2q">
<em class="property">classmethod </em><code class="sig-name descname">map_xi2q</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xi_</span></em>, <em class="sig-param"><span class="n">xAux_</span></em>, <em class="sig-param"><span class="n">distType_</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pce.pce.map_xi2q" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps <cite>xi_</cite> in <span class="math notranslate nohighlight">\(\Gamma\)</span> to <cite>x_</cite> in <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>, where <span class="math notranslate nohighlight">\(\Gamma\)</span> is the 
mapped space corresponding to the standard gPCE.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt><cite>xi_</cite>: 1D numpy array of size n</dt><dd><p>Samples taken from the mapped parameter space</p>
</dd>
<dt><cite>distType_</cite>: string </dt><dd><p>Distribution type of the parameter</p>
</dd>
<dt><cite>xAux</cite>: List of length 2</dt><dd><ul class="simple">
<li><p>xAux==xBound (admissible range) if distType_==’Unif’, hence <span class="math notranslate nohighlight">\(\Gamma=[-1,1]\)</span></p></li>
<li><p>xAux==[m,sdev]  if disType_==’Norm’, where x_~N(m,sdev^2) and <span class="math notranslate nohighlight">\(\Gamma=[-\infty,\infty]\)</span></p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt><cite>x_</cite>: 1D numpy array of size n</dt><dd><p>Mapped parameter value in <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pce.pceEval">
<em class="property">class </em><code class="sig-prename descclassname">pce.</code><code class="sig-name descname">pceEval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coefs</span></em>, <em class="sig-param"><span class="n">xi</span></em>, <em class="sig-param"><span class="n">distType</span></em>, <em class="sig-param"><span class="n">kSet</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pce.pceEval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates a constructed PCE at test samples taken from the parameter space.
The parameter space has dimension p.
The number of test samples is m.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt><cite>coefs</cite>: 1D numpy array of size K</dt><dd><p>PCE coefficients</p>
</dd>
<dt><cite>xi</cite>: A list of length p</dt><dd><p><cite>xi=[xi_1,xi_2,..,xi_p]</cite>, where <cite>xi_k</cite> is a 1D numpy array containing 
<cite>m_k</cite> test samples taken from the mapped space of the k-th parameter. 
Always a tensor-product grid of the test samples is constructed over the p-D space, 
therefore, <cite>m=m_1*m_2*…*m_p</cite>.</p>
</dd>
<dt><cite>distType</cite>: List of length p of strings, </dt><dd><p>The i-th value specifies the distribution type of the i-th parameter (based on the gPCE rule)</p>
</dd>
<dt><cite>kSet</cite>: (optional, required only if p&gt;1) List of length <cite>K</cite></dt><dd><p>The index set produced when constructing the PCE with a specified truncation scheme.          
<span class="math notranslate nohighlight">\(kSet=[[k_{1,1},k_{2,1},...k_{p,1}],...,[k_{1,K},k_{2,K},..,k_{p,K}]]\)</span> with <span class="math notranslate nohighlight">\(k_{i,j}\)</span> being integer</p>
</dd>
</dl>
</dd>
<dt>Attribute:</dt><dd><dl class="simple">
<dt><cite>pceVal</cite>: 1D numpy array of size m,</dt><dd><p>Response values predicted (interpolated) by the PCE at the test samples</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="pce.pceEval.eval_1d">
<code class="sig-name descname">eval_1d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.pceEval.eval_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates a PCE over a 1D parameter space at a set of test samples xi 
taken from the mapped parameter space.</p>
</dd></dl>

<dl class="py method">
<dt id="pce.pceEval.eval_pd">
<code class="sig-name descname">eval_pd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pce.pceEval.eval_pd" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates a PCE over a p-D (p&gt;1) parameter space at a set of test samples xi 
taken from the mapped parameter space.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="notebook">
<h3>Notebook<a class="headerlink" href="#notebook" title="Permalink to this headline">¶</a></h3>
<p>Try the <a class="reference internal" href="../examples/pce.html"><span class="doc">PCE notebook</span></a> to see how to use <code class="code docutils literal notranslate"><span class="pre">UQit</span></code> to perform standard polynomial chaos expansion (PCE). The provided examples can also be seen as a way to validate the implementation of the methods in <code class="code docutils literal notranslate"><span class="pre">UQit</span></code>.</p>
</div>
</div>
<div class="section" id="probabilistic-polynomial-chaos-expansion">
<h2>Probabilistic Polynomial Chaos Expansion<a class="headerlink" href="#probabilistic-polynomial-chaos-expansion" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id14">
<h3>Theory<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>The standard PCE (polynomial chaos expansion) and GPR (Gaussian process regression) are two powerful approaches for surrogate construction and metamodeling in UQ.
Combining these two approaches, probabilistic PCE is derived.
There are at least two different views to this derivation which can be found in Schobi et al. <a class="reference internal" href="../bib.html#schobi15" id="id15"><span>[Schobi15]</span></a> and Owen <a class="reference internal" href="../bib.html#owen17" id="id16"><span>[Owen17]</span></a>.
In <code class="code docutils literal notranslate"><span class="pre">UQit</span></code>, a generalization of the latter is implemented which is detailed in <a class="reference internal" href="../bib.html#rezaeiravesh20" id="id17"><span>[Rezaeiravesh20]</span></a>.</p>
</div>
<div class="section" id="id18">
<h3>Example<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>Given training parameter samples <code class="code docutils literal notranslate"><span class="pre">qTrain</span></code> and associated responses <code class="code docutils literal notranslate"><span class="pre">yTrain</span></code> with observation noise <code class="code docutils literal notranslate"><span class="pre">noiseSdev</span></code>, the <code class="code docutils literal notranslate"><span class="pre">ppce</span></code> is constructed as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ppce_</span><span class="o">=</span><span class="n">ppce</span><span class="o">.</span><span class="n">ppce</span><span class="p">(</span><span class="n">qTrain</span><span class="p">,</span><span class="n">yTrain</span><span class="p">,</span><span class="n">noiseSdev</span><span class="p">,</span><span class="n">ppceDict</span><span class="p">)</span>
<span class="n">optOut</span><span class="o">=</span><span class="n">ppce_</span><span class="o">.</span><span class="n">optOut</span>
<span class="n">fMean_samples</span><span class="o">=</span><span class="n">ppce_</span><span class="o">.</span><span class="n">fMean_samps</span>
<span class="n">fVar_samples</span><span class="o">=</span><span class="n">ppce_</span><span class="o">.</span><span class="n">fVar_samps</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>Implementation<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-ppce"></span><dl class="py class">
<dt id="ppce.ppce">
<em class="property">class </em><code class="sig-prename descclassname">ppce.</code><code class="sig-name descname">ppce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">qTrain</span></em>, <em class="sig-param"><span class="n">yTrain</span></em>, <em class="sig-param"><span class="n">noiseV</span></em>, <em class="sig-param"><span class="n">ppceDict</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ppce.ppce" title="Permalink to this definition">¶</a></dt>
<dd><p>Probabilistic Polynomial Chaos Expansion (PPCE) over a p-D parameter space, 
where p=1,2,…
Model: y=f(q)+e</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt><cite>qTrain</cite>: 2D numpy array of shape (n,p)</dt><dd><p>Training samples for q</p>
</dd>
<dt><cite>yTrain</cite>: 1D numpy array of size n</dt><dd><p>Training observed values for y</p>
</dd>
<dt><cite>noiseV</cite>: 1D numpy array of size n</dt><dd><p>Standard-deviation of the noise in the training observations: e~N(0,noiseSdev)</p>
</dd>
<dt><cite>ppceDict</cite>: dict</dt><dd><dl>
<dt>Dictionary containing controllers for PPCE, including:</dt><dd><ul>
<li><dl class="simple">
<dt>‘nGQtest’: List of length p</dt><dd><p>Number of GQ test points in each of the p-directions</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘qInfo’: List of length p</dt><dd><dl class="simple">
<dt>=[qInfo_1,…,qInfo_p], where qInfo_i is the information about distribution of q_i</dt><dd><ul class="simple">
<li><p>if q_i~’Unif’, qInfo_i =[min(q_i),max(q_i)]</p></li>
<li><p>if q_i~’Norm’, qInfo_i =[m,v] for q~N(m,v^2)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘nMC’: int</dt><dd><p>Number of independent samples drawn from the GPR to construct PCE</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘nIter_gpr’: int</dt><dd><p>Number of iterations for optimization of the GPR hyper-parameters</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘lr_gpr’: float</dt><dd><p>Learning rate for optimization of the GPR hyper-parameters</p>
</dd>
</dl>
</li>
<li><dl>
<dt>‘standardizeYTrain_gpr’: bool (optional, default: False)</dt><dd><p>If true, the training data are standardized by shifting by mean and scaling by sdev:</p>
<p><span class="math notranslate nohighlight">\(yStnd =  (yTrain-mean(yTrain))/sdev(yTrain)\)</span></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘convPlot_gpr’: bool</dt><dd><p>If true, values of the hyper-parameters are plotted vs. iteration during the optimization.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl class="simple">
<dt><cite>fMean_list</cite>: 1D numpy array of size <cite>nMC</cite></dt><dd><p>PCE estimates for the mean of f(q)</p>
</dd>
<dt><cite>fVar_list</cite>: 1D numpy array of size <cite>nMC</cite></dt><dd><p>PCE estimates for the variance of f(q)</p>
</dd>
<dt><cite>optOut</cite>: dict</dt><dd><dl class="simple">
<dt>Optional outputs for plotting using gprPlot, with the following keys:    </dt><dd><ul class="simple">
<li><p><cite>post_f</cite>: Posterior density of f(q)</p></li>
<li><p><cite>post_obs</cite>: Posterior density of y</p></li>
<li><p><cite>qTest</cite>: A List of length p, 
=[qTest_1,qTest_2,…,qTest_p], where qTest_i is a 1D numpy array of size 
<cite>ppceDict[‘nGQtest’][i]</cite> containing the GQ test samples in the i-th direction
of the parameter.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="ppce.ppce.ppce_cnstrct_1d">
<code class="sig-name descname">ppce_cnstrct_1d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ppce.ppce.ppce_cnstrct_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructing a probabilistic PCE over a 1D parameter space</p>
</dd></dl>

<dl class="py method">
<dt id="ppce.ppce.ppce_cnstrct_pd">
<code class="sig-name descname">ppce_cnstrct_pd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ppce.ppce.ppce_cnstrct_pd" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructing a probabilistic PCE over a p-D parameter space, p&gt;1</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id20">
<h3>Notebook<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>Try this <a class="reference internal" href="../examples/ppce.html"><span class="doc">PPCE notebook</span></a> to see how to use <code class="code docutils literal notranslate"><span class="pre">UQit</span></code> to perform probabilistic polynomial chaos expansion (PPCE).</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gsa.html" class="btn btn-neutral float-right" title="Global Sensitivity Analysis (GSA)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="surrogate.html" class="btn btn-neutral float-left" title="Surrogates" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Saleh Rezaeiravesh

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>